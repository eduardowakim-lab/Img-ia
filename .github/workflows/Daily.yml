name: Imagem do Dia

on:
  schedule:
    - cron: "0 11 * * *"   # 08:00 America/Sao_Paulo
  workflow_dispatch: {}

jobs:
  run-daily:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Instalar dependências
        run: |
          python -m pip install --upgrade pip requests feedparser

      - name: Gerar imagem e enviar e-mail (com legenda de notícia do dia)
        timeout-minutes: 15
        run: |
          cat > script.py <<'EOF'
          import os, time, json, base64, requests, smtplib, mimetypes, sys, traceback, feedparser
          from email.message import EmailMessage
          from datetime import datetime, timezone, timedelta
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry
          from urllib.parse import quote_plus

          # ---- Config ----
          OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
          PROMPT   = os.getenv("PROMPT") or "Um nascer do sol nas montanhas do Brasil, estilo realista"
          SIZE     = os.getenv("IMG_SIZE") or "1024x1024"
          NEWS_QUERY = (os.getenv("NEWS_QUERY") or "").strip()  # opcional, para filtrar tema

          try:
              N_IMAGES = int(os.getenv("N_IMAGES") or 1)
          except ValueError:
              N_IMAGES = 1

          OUT_NAME = "daily.png"

          SMTP_USER = os.getenv("SMTP_USER")
          SMTP_PASS = os.getenv("SMTP_PASS")
          SMTP_TO   = (os.getenv("SMTP_TO") or "").strip()
          SMTP_HOST = os.getenv("SMTP_HOST") or "smtp.gmail.com"
          try:
              SMTP_PORT = int(os.getenv("SMTP_PORT") or 587)
          except ValueError:
              SMTP_PORT = 587

          # Envs obrigatórios
          required = ("OPENAI_API_KEY","SMTP_USER","SMTP_PASS","SMTP_TO")
          missing = [k for k in required if not os.getenv(k)]
          if missing:
              print("Faltando variáveis: " + ", ".join(missing), file=sys.stderr)
              sys.exit(1)

          if "@" not in SMTP_TO:
              print(f"SMTP_TO inválido: '{SMTP_TO}'", file=sys.stderr)
              sys.exit(1)

          # ---- Sessão HTTP robusta (retries/backoff) ----
          def session_with_retries():
              retry = Retry(
                  total=6, connect=3, read=3,
                  backoff_factor=1.5,
                  status_forcelist=(408,409,429,500,502,503,504),
                  allowed_methods=frozenset(["GET","POST"])
              )
              adapter = HTTPAdapter(max_retries=retry, pool_maxsize=20)
              s = requests.Session()
              s.mount("https://", adapter)
              s.mount("http://", adapter)
              s.headers.update({"Connection": "close"})
              return s

          HTTP_TIMEOUT = (15, 360)  # (connect, read)

          # ---- Notícias (Google News RSS) ----
          def fetch_top_news():
              """
              Retorna dict: {title, summary, link, published}
              Usa BR/pt-BR. Se NEWS_QUERY setado, usa feed de busca.
              """
              base_general = "https://news.google.com/rss?hl=pt-BR&gl=BR&ceid=BR:pt-419"
              if NEWS_QUERY:
                  url = f"https://news.google.com/rss/search?q={quote_plus(NEWS_QUERY)}&hl=pt-BR&gl=BR&ceid=BR:pt-419"
              else:
                  url = base_general

              print(f"[news] Buscando feed: {url}")
              # feedparser já trata redirects e gzip; manter retry via requests para baixar XML cru
              s = session_with_retries()
              r = s.get(url, timeout=(10, 30))
              r.raise_for_status()
              feed = feedparser.parse(r.content)

              if not feed.entries:
                  raise SystemExit("Não foi possível obter notícias do dia.")

              # Pega o primeiro item “mais quente”
              e = feed.entries[0]
              title = e.get("title", "").strip()
              summary = (e.get("summary") or e.get("description") or "").strip()
              link = e.get("link", "").strip()
              published = e.get("published", "").strip()
              # sanitização simples
              summary = summary.replace("\n", " ")
              return {
                  "title": title,
                  "summary": summary,
                  "link": link,
                  "published": published
              }

          # ---- OpenAI: imagem (independente da notícia) ----
          IMG_URL = "https://api.openai.com/v1/images/generations"
          IMG_HEADERS = {"Authorization": f"Bearer {OPENAI_API_KEY}", "Content-Type": "application/json", "Connection": "close"}
          IMG_PAYLOAD = {"model": "gpt-image-1", "prompt": PROMPT, "size": SIZE, "n": N_IMAGES}

          def generate_image(max_retries=3, delay=15):
              s = session_with_retries()
              last_err_txt = None
              for i in range(1, max_retries+1):
                  try:
                      print(f"[img] Tentativa {i}/{max_retries}…")
                      r = s.post(IMG_URL, headers=IMG_HEADERS, json=IMG_PAYLOAD, timeout=HTTP_TIMEOUT)
                      if r.status_code != 200:
                          txt = r.text[:800]; print(f"[img] HTTP {r.status_code}: {txt}"); last_err_txt = txt
                          if r.status_code == 403 and "must be verified" in txt.lower():
                              raise SystemExit("403: Organização não verificada p/ gpt-image-1.")
                          if i < max_retries: print(f"[img] Backoff {delay}s…"); time.sleep(delay); continue
                          raise SystemExit("Falha ao gerar imagem.")
                      data = r.json()
                      if not data.get("data"):
                          print("[img] Resposta inesperada:", json.dumps(data)[:800])
                          if i < max_retries: time.sleep(delay); continue
                          raise SystemExit("Sem dados de imagem.")
                      item = data["data"][0]
                      if "b64_json" in item:
                          with open(OUT_NAME, "wb") as f: f.write(base64.b64decode(item["b64_json"]))
                          print(f"[OK] Imagem salva em {OUT_NAME} (b64)."); return OUT_NAME
                      elif "url" in item:
                          img = s.get(item["url"], timeout=HTTP_TIMEOUT); img.raise_for_status()
                          with open(OUT_NAME, "wb") as f: f.write(img.content)
                          print(f"[OK] Imagem salva em {OUT_NAME} (url)."); return OUT_NAME
                      else:
                          print("[img] Item sem b64_json/url:", item)
                          if i < max_retries: time.sleep(delay); continue
                          raise SystemExit("Formato de resposta não suportado.")
                  except requests.exceptions.RequestException as e:
                      print("[img] Erro de rede:", repr(e))
                      if i < max_retries: time.sleep(delay); continue
                      raise SystemExit("Falhou após múltiplas tentativas (imagem).")
              if last_err_txt: print("[img] Último erro:", last_err_txt)
              raise SystemExit("Falha após múltiplas tentativas (imagem).")

          # ---- OpenAI: legenda/caption a partir da notícia ----
          CHAT_URL = "https://api.openai.com/v1/chat/completions"
          CHAT_HEADERS = {"Authorization": f"Bearer {OPENAI_API_KEY}", "Content-Type": "application/json", "Connection": "close"}

          def generate_caption_from_news(news, max_retries=3, delay=10):
              """
              news: dict(title, summary, link, published)
              Produz 1–2 frases, ~240 chars + 3–5 hashtags no fim.
              """
              s = session_with_retries()
              sys_prompt = (
                  "Você é um redator social em PT-BR. Escreva UMA legenda curta sobre a notícia fornecida, "
                  "com no máximo ~240 caracteres, 1–2 frases, sem hashtags no meio das frases; "
                  "adicione 3–5 hashtags no final. Sem emojis obrigatórios. Evite clickbait barato."
              )
              user_prompt = (
                  f"Título: {news['title']}\n"
                  f"Resumo: {news['summary']}\n"
                  f"Link: {news['link']}\n"
                  "Entregue apenas a legenda final."
              )
              payload = {
                  "model": "gpt-4o-mini",
                  "messages": [
                      {"role": "system", "content": sys_prompt},
                      {"role": "user", "content": user_prompt}
                  ],
                  "temperature": 0.8,
                  "max_tokens": 160
              }
              last_err_txt = None
              for i in range(1, max_retries+1):
                  try:
                      print(f"[caption] Tentativa {i}/{max_retries}…")
                      r = s.post(CHAT_URL, headers=CHAT_HEADERS, json=payload, timeout=HTTP_TIMEOUT)
                      if r.status_code != 200:
                          txt = r.text[:800]; print(f"[caption] HTTP {r.status_code}: {txt}"); last_err_txt = txt
                          if i < max_retries: print(f"[caption] Backoff {delay}s…"); time.sleep(delay); continue
                          break
                      data = r.json()
                      content = data["choices"][0]["message"]["content"].strip().replace("\n", " ").strip()
                      return content
                  except requests.exceptions.RequestException as e:
                      print("[caption] Erro de rede:", repr(e))
                      if i < max_retries: time.sleep(delay); continue
                      break
              print("[caption] Fallback local.")
              return "Resumo do dia pronto para o feed. #notícias #hoje #brasil"

          # ---- Execução: pega notícia -> gera imagem -> legenda com base na notícia ----
          news = fetch_top_news()
          img_path = generate_image()
          caption = generate_caption_from_news(news)

          # ---- E-mail ----
          msg = EmailMessage()
          msg["Subject"] = "Imagem do dia (com legenda baseada na notícia)"
          msg["From"] = SMTP_USER
          msg["To"] = SMTP_TO
          tz = timezone(timedelta(hours=-3))  # America/Sao_Paulo
          body = (
              f"Gerado em {datetime.now(tz):%d/%m/%Y %H:%M}\n"
              f"Modelo imagem: gpt-image-1\n"
              f"Prompt imagem: {PROMPT}\n"
              f"Tamanho: {SIZE}\n"
              f"Imagens: {N_IMAGES}\n\n"
              f"Notícia usada:\n"
              f"- Título: {news['title']}\n"
              f"- Publicado: {news.get('published')}\n"
              f"- Link: {news['link']}\n\n"
              f"Legenda sugerida para Instagram:\n"
              f"{caption}\n"
          )
          msg.set_content(body)

          # anexa a imagem
          ctype, _ = mimetypes.guess_type(img_path)
          if not ctype: ctype = "image/png"
          maintype, subtype = ctype.split("/", 1)
          with open(img_path, "rb") as f:
              msg.add_attachment(f.read(), maintype=maintype, subtype=subtype, filename=img_path)

          # anexa a legenda como txt
          msg.add_attachment(caption.encode("utf-8"), maintype="text", subtype="plain", filename="caption.txt")

          # Envio SMTP
          try:
              s = smtplib.SMTP(SMTP_HOST, SMTP_PORT, timeout=60)
              s.set_debuglevel(1)
              s.ehlo()
              if SMTP_PORT == 587:
                  s.starttls(); s.ehlo()
              s.login(SMTP_USER, SMTP_PASS)
              refused = s.send_message(msg)
              s.quit()
          except smtplib.SMTPAuthenticationError as e:
              print("Falha na autenticação SMTP. Use senha de app se for Gmail.", file=sys.stderr)
              print(e.smtp_code, e.smtp_error, file=sys.stderr); sys.exit(1)
          except smtplib.SMTPRecipientsRefused as e:
              print("Destinatário recusado.", file=sys.stderr); print(str(e), file=sys.stderr); sys.exit(1)
          except smtplib.SMTPSenderRefused as e:
              print("Remetente recusado. O 'From' deve ser igual ao login.", file=sys.stderr)
              print(str(e), file=sys.stderr); sys.exit(1)
          except smtplib.SMTPDataError as e:
              print("SMTPDataError.", file=sys.stderr); print(e.smtp_code, e.smtp_error, file=sys.stderr); sys.exit(1)
          except Exception:
              print("Erro inesperado ao enviar e-mail:\n" + traceback.format_exc(), file=sys.stderr); sys.exit(1)

          if refused:
              print(f"Aviso: servidor recusou alguns destinatários: {refused}", file=sys.stderr); sys.exit(1)

          print("E-mail enviado com sucesso! (imagem + legenda da notícia)")
          EOF

          python script.py
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SMTP_USER:  ${{ secrets.SMTP_USER }}
          SMTP_PASS:  ${{ secrets.SMTP_PASS }}
          SMTP_TO:    ${{ vars.SMTP_TO }}
          PROMPT:     ${{ vars.PROMPT }}       # só afeta a IMAGEM; a legenda vem da notícia real
          IMG_SIZE:   ${{ vars.IMG_SIZE }}     # ex: 1024x1024
          N_IMAGES:   ${{ vars.N_IMAGES }}     # se vazio, cai em 1
          SMTP_HOST:  ${{ vars.SMTP_HOST }}    # opcional
          SMTP_PORT:  ${{ vars.SMTP_PORT }}    # opcional
          NEWS_QUERY: ${{ vars.NEWS_QUERY }}   # opcional (ex.: "Bolsa de valores", "NASA")
